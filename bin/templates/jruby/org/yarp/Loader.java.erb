package org.yarp;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;

import org.jruby.parser.StaticScope;
import org.jruby.parser.StaticScopeFactory;

// GENERATED BY <%= File.basename(__FILE__) %>
// @formatter:off
public class Loader {
    private final byte[] source;
    private final String fileName;
    private final ByteBuffer buffer;
    private StaticScope staticScope = null;

    public static Nodes.Node load(String fileName, byte[] source, byte[] serialized) {
        return new Loader(fileName, source, serialized).load();
    }

    private Loader(String fileName, byte[] source, byte[] serialized) {
        this.fileName = fileName;
        this.source = source;
        this.buffer = ByteBuffer.wrap(serialized).order(ByteOrder.nativeOrder());    }

    private Nodes.Node load() {
        expect((byte) 'Y');
        expect((byte) 'A');
        expect((byte) 'R');
        expect((byte) 'P');

        expect((byte) 0);
        expect((byte) 4);
        expect((byte) 0);

        return loadNode();
    }

    // FIXME: this should be iso_8859_1 strings and not default charset.
    private String[] tokensToStrings(Nodes.Token[] tokens) {
        String[] strings = new String[tokens.length];

        for (int i = 0; i < tokens.length; i++) {
            Nodes.Token token = tokens[i];
            strings[i] = new String(source, token.startOffset, token.endOffset - token.startOffset);
        }

        return strings;
    }

    // FIXME: our staticscope assumes we know first offset to kwargs.
    private StaticScope loadStaticScope() {
        int type = buffer.get() & 0xFF;
        int startOffset = buffer.getInt();
        int endOffset = buffer.getInt();

        staticScope = StaticScopeFactory.newStaticScope(staticScope, StaticScope.Type.LOCAL, fileName, tokensToStrings(loadTokens()), -1);
                            
        return staticScope;
    }

    private byte[] loadString() {
        int length = buffer.getInt();
        byte[] string = new byte[length];
        buffer.get(string);
        return string;
    }

    private Nodes.Token loadOptionalToken() {
        if (buffer.get(buffer.position()) != 0) {
            return loadToken();
        } else {
            buffer.position(buffer.position() + 1); // continue after the 0 byte
            return null;
        }
    }

    private Nodes.Node loadOptionalNode() {
        if (buffer.get(buffer.position()) != 0) {
            return loadNode();
        } else {
            buffer.position(buffer.position() + 1); // continue after the 0 byte
            return null;
        }
    }

    private Nodes.Token[] loadTokens() {
        int length = buffer.getInt();
        Nodes.Token[] tokens = new Nodes.Token[length];
        for (int i = 0; i < length; i++) {
            tokens[i] = loadToken();
        }
        return tokens;
    }

    private Nodes.Node[] loadNodes() {
        int length = buffer.getInt();
        Nodes.Node[] nodes = new Nodes.Node[length];
        for (int i = 0; i < length; i++) {
            nodes[i] = loadNode();
        }
        return nodes;
    }

    private Nodes.Token loadToken() {
        int type = buffer.get() & 0xFF;
        int startOffset = buffer.getInt();
        int endOffset = buffer.getInt();

        final Nodes.TokenType tokenType = Nodes.TOKEN_TYPES[type];
        return new Nodes.Token(tokenType, startOffset, endOffset);
    }

    private Nodes.Location loadLocation() {
        int startOffset = buffer.getInt();
        int endOffset = buffer.getInt();
        return new Nodes.Location(startOffset, endOffset);
    }

    private Nodes.Location loadOptionalLocation() {
        if (buffer.get() != 0) {
            return loadLocation();
        } else {
            return null;
        }
    }

    private int loadInteger() {
        return buffer.getInt();
    }

    <%- nodes.each_with_index do |node, index| -%>
    private Nodes.Node load<%= node.name %>(int startOffset, int endOffset) {
        return new Nodes.<%= node.name -%>(<%= (node.params.to_a.delete_if(&:exclude).map { |param|
             case param
             when NodeParam then "load#{param.java_load_type}()"
             when OptionalNodeParam then "loadOptionalNode()"
             when StringParam then "loadString()"
             when NodeListParam then "loadNodes()"
             when TokenParam then "loadToken()"
             when TokenListParam then "loadTokens()"
             when OptionalTokenParam then "loadOptionalToken()"
             when LocationParam then "loadLocation()"
             when OptionalLocationParam then "loadOptionalLocation()"
             when IntegerParam then "loadInteger()"
             else raise
             end
            } + ["startOffset", "endOffset"]).join(", ") -%>);
    }
    <%- end -%>
                            

    private Nodes.Node loadNode() {
        int type = buffer.get() & 0xFF;
        int startOffset = buffer.getInt();
        int endOffset = buffer.getInt();

        switch (type) {
        <%- nodes.each_with_index do |node, index| -%>
        case <%= index %>: return load<%= node.name %>(startOffset, endOffset);
        <%- end -%>
        default:
            throw new Error("Unknown node type: " + type);
        }
    }

    private void expect(byte value) {
        byte b = buffer.get();
        if (b != value) {
            throw new Error("Expected " + value + " but was " + b + " at position " + buffer.position());
        }
    }

}
// @formatter:on
